/*
 * generated by Xtext 2.13.0
 */
package ma.kvmod.pidm.lang.scoping

import ma.kvmod.pidm.lang.pidm.Lang.Alias
import ma.kvmod.pidm.lang.pidm.Lang.Attribute
import ma.kvmod.pidm.lang.pidm.Lang.AttributeSelection
import ma.kvmod.pidm.lang.pidm.Lang.BooleanExpression
import ma.kvmod.pidm.lang.pidm.Lang.Entity
import ma.kvmod.pidm.lang.pidm.Lang.From
import ma.kvmod.pidm.lang.pidm.Lang.PidmLangPackage
import ma.kvmod.pidm.lang.pidm.Lang.Inclusion
import ma.kvmod.pidm.lang.pidm.Lang.Model
import ma.kvmod.pidm.lang.pidm.Lang.Query
import ma.kvmod.pidm.lang.pidm.Lang.Reference
import java.util.ArrayList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.scoping.Scopes

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class PidmLangScopeProvider extends AbstractPidmLangScopeProvider {
  override getScope(EObject context, EReference reference) {
    if (context instanceof AttributeSelection) {
      if (reference == PidmLangPackage.Literals.ATTRIBUTE_SELECTION__REF_ALIAS) {
        val query = getQueryFromContainer(context.eContainer)
        val aliases = new ArrayList<Alias>
        if (query.from !== null && query.from.alias !== null) {
          aliases.add(query.from.alias)
        }
        aliases.addAll(query.inclusions.filter(j | j.alias !== null)
                                       .map[j | j.alias])
        return Scopes.scopeFor(aliases)
      } else if (reference == PidmLangPackage.Literals.ATTRIBUTE_SELECTION__ATTRIBUTE) {
        if ((context as AttributeSelection).refAlias !== null) {
          var Entity entity = getEntity((context as AttributeSelection).refAlias)
          if (entity !== null) {
            var attributes = entity.features.filter[f | f instanceof Attribute]
            return Scopes.scopeFor(attributes)
          }
        }
      }
    }
    if (context instanceof Inclusion) {
      if (reference == PidmLangPackage.Literals.INCLUSION__REF_ALIAS) {
        val query = context.eContainer as Query
        val aliases = new ArrayList<Alias>
        if (query.from !== null && query.from.alias !== null) {
          aliases.add(query.from.alias)
        }
        aliases.addAll(query.inclusions.filter(j | j.alias !== null)
                                       .map[j | j.alias])
        return Scopes.scopeFor(aliases)
      } else if (reference == PidmLangPackage.Literals.INCLUSION__REFS
            && (context as Inclusion).refAlias !== null) {
        // All refs in the model as scope: this allows wrong reference chains
        //TODO: check the chain is correct in the validator (easier)
        val model = EcoreUtil.getRootContainer(context) as Model
        val references = model.eAllContents
                              .filter(elem | elem instanceof Reference)
                              .map(elem | elem as Reference).toIterable
        return Scopes.scopeFor(references)
      }
    }
    return super.getScope(context, reference);
  }
  
  def Query getQueryFromContainer(EObject container) {
    if (container instanceof Query) {
      return container as Query
    } else if (container instanceof BooleanExpression) {
      var EObject node = container
      while (!(node instanceof Query)) {
        node = node.eContainer
      }
      return node as Query
    }
  }

  def Entity getEntity(Alias alias) {
    if (alias === null) {
      return null
    }
    val container = alias.eContainer
    if (container instanceof From) {
        return (container as From).entity
    } else if (container instanceof Inclusion) {
      return (container as Inclusion).refs.last.entity
    }
  }
}
